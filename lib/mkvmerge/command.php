<?php
/**
 * File containing the MKVMergeCommand class
 *
 * @version $Id$
 * @copyright 2010
 */

/**
 * This class allows manipulation of a mkvmerge command generated by the GUI
 *
 *@property-read array VideoFiles
 *@property-read array SubtitleFiles
 *@property-read int TargetSize
 */
class MKVMergeCommand
{
    /**
     * Constructor
     *
     * @param string $command A mkvmerge command generated from the GUI
     * @param string $targetDisk A mkvmerge command generated from the GUI
     */
    function __construct( $command, $time = null )
    {
        if ( $time !== null )
            $this->time = $time;
        $this->command = $command;
        $this->_extractType();
        $this->_extractFiles();

    }

    protected function _extractFiles()
    {
        // Movie
        if ( $this->conversionType == 'movie' )
        {
            // parse the command to get the target / sources
            if ( preg_match( '#/media/storage/[^/]+/Movies/([^/]+)(/\1)?\.(avi|mkv)#', $this->command, $matches ) )
            {
                $this->targetPath = $matches[0];
                $this->title = $matches[1];
                $this->target = dirname( $matches[0] );

                // Replace the output conversion so that there is a subfolder for the movie
                if ( $matches[2] == '' )
                {
                    $this->target .= DIRECTORY_SEPARATOR . $this->title;
                    $fileTarget = $this->target . DIRECTORY_SEPARATOR . $this->title . '.' . $matches[3];
                    $this->command = str_replace( $matches[0], $fileTarget, $this->command );
                }
            }
            else
            {
                throw new Exception( "Error extracting files from the command: {$this->command}" );
            }
            $this->linkTarget = "/media/aggregateshares/Movies/";
        }

        // TV Show
        elseif ( $this->conversionType == 'tvshow' )
        {
            // TV Show subfolder
            if ( preg_match( '#/media/storage/[^/]+/TV Shows/([^/]+)/([^/]+)\.(avi|mkv)#', $this->command, $matches ) )
            {
                $this->target = $this->targetPath = $matches[0];

                $this->showName = $matches[1];
                $this->episodeName = $matches[2];
            }
            // no subfolder
            elseif ( preg_match( '#/media/storage/[^/]+/TV Shows/(([^/]+) \- [0-9]+x[0-9\-]+ \- .*?)\.(avi|mkv)#', $this->command, $matches ) )
            {
                $this->target = $matches[0];

                $this->showName = $matches[2];
                $this->episodeName = $matches[1];

                $replace = $matches[2] . DIRECTORY_SEPARATOR . $matches[1];

                $this->target = str_replace( $this->episodeName, $replace, $this->target );
                $this->command = str_replace( $matches[0], $this->target, $this->command );
            }
            else
            {
                throw new Exception( "Error extracting files from the command: {$this->command}" );
            }

            $this->title = $this->episodeName;
            $this->linkTarget = "/media/aggregateshares/TV Shows/{$this->showName}/";
        }
    }

    /**
     * Analyzes the command and stores the conversion type (movie / tvshow)
     * in self::$type
     */
    protected function _extractType()
    {
        if ( strpos( $this->command, '/complete/Movies/' ) !== false )
        {
            $this->conversionType = 'movie';
        }
        elseif ( strpos( $this->command, '/complete/TV/' ) !== false )
        {
            $this->conversionType = 'tvshow';
        }
        else
            throw new Exception( "Unable to extract the conversion type" );
    }

    /**
     * Returns the command string formatted according to a few settings:
     * {@link $appendSymLink} Wether or not to append a symbolic link creation command
     * {@link $appendDoneText} Wether or not to append a message saying confirmation's complete
     *
     * @return string
     */
    public function toStruct()
    {
        $data = array();
        $data['Command'] = $this->command;
        $data['SubtitleFiles'] = $this->SubtitleFiles;
        $data['VideoFiles'] = $this->VideoFiles;
        $data['TargetSize'] = $this->TargetSize;

        if ( $this->appendSymLink === true )
            $data['Command'] .= "; ln -s '$this->target' '$this->linkTarget'";
        if ( $this->appendDoneText === true )
            $data['Command'] .= "; echo \"Done converting '$this->title'";

        return $data;
    }

    /**
     * Returns a string representation of the command, depending on the options:
     * {@see $appendSymLink} and {@see $appendDoneText}
     *
     * @return string
     */
    public function asString()
    {
        $string = $this->command;
        if ( $this->appendSymLink === true )
        {
            $string .= "; if [ ! -f '$this->linkTarget' ]; then ln -fs '$this->target' '$this->linkTarget'; fi";
        }
        if ( $this->appendDoneText === true )
            $string .= "; echo \"Done converting $this->title\"";

        return $string;
    }

    public function __get( $property )
    {
        switch ( $property )
        {
            case 'videoFiles':  // BC
            case 'VideoFiles':
                return $this->_extractCommandFiles( 'video' );
                break;
            case 'subtitleFiles': // BC
            case 'SubtitleFiles':
                return $this->_extractCommandFiles( 'subtitle');
                break;
            case 'TargetSize':
                return $this->_targetSize();
                break;
            default:
                throw new ezcBasePropertyNotFoundException( $property );
        } // switch
    }

    /**
     * Returns the video files involved in the command
     * @param string $type subtitle or video
     * @return string
     */
    protected function _extractCommandFiles( $type )
    {
        $return = array();

        switch ( $type)
        {
            case 'video':
            {
                $extensions = '(avi|mkv)';
            } break;

            case 'subtitle':
            {
                $extensions = '(srt|ass)';
            } break;

            default:
                throw new UnexpectedValueException( "Invalid argument given to " . __FUNCTION__ );
        }
        if ( preg_match_all( "#/home/download/downloads/complete/(TV/Sorted|Movies)/([^\/]+)/([^\"]+\.{$extensions})#", $this->command, $matches ) )
        {
            foreach( $matches[0] as $match )
            {
                $item = new MKVMergeSourceFile( $match );
                $return[] = $item->asArray();
            }
        }

        return $return;
    }

    protected function _targetSize()
    {
        $size = (double)0;

        foreach( $this->VideoFiles as $videoFile )
        {
            $size += $videoFile['size'];
        }

        foreach( $this->SubtitleFiles as $subtitleFile )
        {
            $size += $subtitleFile['path'];
        }

        return $size;
    }


    /**
     * The final command, after conversion
     * @var string
     */
    public $command;

    /**
     * Conversion type: movie/tvshow
     */
    public $conversionType;

    /**
     * The conversion title, either the movie name, or the tv show name + episode
     * @var string
     */
    public $title;

    /**
    /**
     * The conversion target folder
     * @var string
     */
    public $target;

    /**
     * The TV Show name. Only set for $type == tvshow
     * @var string
     */
    public $showName;

    /**
     * The TV Show episode name. Only set for $type == tvshow
     * @var string
     */
    public $episodeName;

    /**
     * The target to be used as the symbolic link
     * @var string
     */
    public $linkTarget;

    /**
     * The command time, as stored in the queue. Optional.
     * @var int timestamp
     */
    public $time;

    public $appendSymLink = false;

    public $appendDoneText = false;

    public $targetPath = '';
}
?>
